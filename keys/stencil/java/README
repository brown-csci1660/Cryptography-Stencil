You can compile your *.java files using the `make build` command.
This will compile them into several *.class files. You can then run
your compiled program using the `java` command and passing your
`pairs` file to standard input like so:

    java -Xmx4g Main < pairs

where `pairs` is the path to your `pairs` file for the Keys problem.
The -Xmx4g flag is used to increase the size of the Java heap, which
may be too small depending on how you're working on the solution.

You can use commands from Cipher.java and ByteArrayWrapper.java in 
Main.java. 

To use any command from Cipher.java, call it using Cipher.encrypt(), 
Cipher.decrypt(), etc. 

ByteWrapperArray.java provides two potentially useful commands: 
equals() and hashCode(). The plaintext/ciphertext pairs are read in 
as hex and converted to byte arrays. However, when comparing byte 
arrays, equality is determined by the object identity rather than the 
contents of the array, which can be a problem if you want to compare 
the equality of two texts. So rather than working directly with byte 
arrays, the plaintext/ciphertext pairs are converted to ByteArrayWrapper 
objects (this is already done for you in the stencil). This allows you 
to use the equals() and hashCode() functions on the plaintexts and 
ciphertexts. The equals() function takes in a ByteArrayWrapper and 
compares it with the calling ByteArrayWrapper. It returns true if the 
two ByteArrayWrappers are value equivatlent and false otherwise. The 
hashCode() function deterministically generates an integer from the 
byte array. This can be a useful form of id for the given byte array.
